<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>π</title>

  <script type="module">
    import { create, all } from "https://esm.sh/mathjs";

    // Get 50 digits of pi as a string using the Chudnovsky algorithm.
    function getPiString(terms = 3, digits = 50) {
      const math = create(all);
      math.config({ number: "BigNumber", precision: 70 });

      const C = math.multiply(
        math.bignumber(426880),
        math.sqrt(math.bignumber(10005))
      );
      const bigNeg = math.bignumber("-262537412640768000");
      const big12 = math.bignumber(12),
            big5 = math.bignumber(5),
            big7 = math.bignumber(7),
            big9 = math.bignumber(9);

      const computePi = (terms) => {
        let M = math.bignumber(1),
            L = math.bignumber(13591409),
            X = math.bignumber(1),
            S = math.bignumber(13591409);
        for (let k = 1; k < terms; k++) {
          let kB = math.bignumber(k);
          M = math.multiply(
            M,
            math.divide(
              math.multiply(
                math.multiply(
                  math.subtract(math.multiply(big12, kB), big5),
                  math.subtract(math.multiply(big12, kB), big7)
                ),
                math.subtract(math.multiply(big12, kB), big9)
              ),
              math.pow(kB, 3)
            )
          );
          L = math.add(L, math.bignumber(545140134));
          X = math.multiply(X, bigNeg);
          S = math.add(S, math.divide(math.multiply(M, L), X));
        }
        return math.divide(C, S);
      };

      const p = computePi(terms);
      return p.toFixed(digits);
    }

    const piStr = getPiString(3, 50);
    // Remove the decimal point.
    const piDigits = piStr.split("").filter(ch => ch !== ".");

    // Map digits to frequencies (Hz) for the flute.
    const noteFrequencies = {
      0: 196.0, // G below middle C
      1: 220.0, // A below middle C
      2: 246.94, // B below middle C
      3: 261.63, // Middle C
      4: 293.66, // D above middle C
      5: 329.63, // E above middle C
      6: 349.23, // F above middle C
      7: 392.0, // G above middle C
      8: 440.0, // A above middle C
      9: 493.88  // B above middle C
    };

    // Calculate each digit's duration:
    // Duration = max(0.3 + (digit - 3)*0.1, 0.2)
    const durations = piDigits.map(digit => {
      const computed = 0.3 + (Number(digit) - 3) * 0.1;
      return computed < 0.2 ? 0.2 : computed;
    });

    // Build an array of scheduled events for the flute.
    let events = [];
    let cumulativeTime = 0;
    for (let i = 0; i < piDigits.length; i++) {
      let digit = piDigits[i];
      let duration = durations[i];
      events.push({
        time: cumulativeTime,  // in seconds
        index: i,
        digit: digit,
        duration: duration,
        freq: noteFrequencies[digit]
      });
      cumulativeTime += duration;
    }
    const totalDuration = cumulativeTime; // seconds

    // Helper: Map a digit to a hue-rotate degree.
    function getHue(digit) {
      return (Number(digit) - 3) * 15;
    }

    // Create an AudioContext.
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let startTime = 0;
    let progressAnimationFrame;

    // Play a single flute tone with a quick attack using an oscillator and gain envelope.
    function playFluteTone(event) {
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      // Set frequency.
      osc.frequency.setValueAtTime(event.freq, 0);
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      // Schedule envelope:
      const eventStart = startTime + event.time;
      const eventEnd = eventStart + event.duration;
      // Quick attack: ramp from 0 to 1 in 0.01 seconds,
      // then decay to 0.8 over 0.2 seconds, sustain until 0.5 seconds before end, then release.
      gainNode.gain.setValueAtTime(0, eventStart);
      gainNode.gain.linearRampToValueAtTime(1, eventStart + 0.01);
      gainNode.gain.linearRampToValueAtTime(0.8, eventStart + 0.01 + 0.2);
      gainNode.gain.setValueAtTime(0.8, eventEnd - 0.5);
      gainNode.gain.linearRampToValueAtTime(0, eventEnd);

      osc.start(eventStart);
      osc.stop(eventEnd);
    }

    // Schedule all flute events.
    function scheduleEvents() {
      startTime = audioCtx.currentTime;
      events.forEach(ev => {
        playFluteTone(ev);
        // Schedule UI update for this event.
        setTimeout(() => {
          const disp = document.getElementById("piDisplay");
          const span = document.createElement("span");
          span.textContent = (ev.index === 1 ? "." : "") + ev.digit;
          span.style.filter = `hue-rotate(${getHue(ev.digit)}deg)`;
          disp.appendChild(span);
        }, ev.time * 1000);
      });
    }

    // Update progress bar based on elapsed time.
    function updateProgress() {
      const progBar = document.getElementById("progress");
      const elapsed = audioCtx.currentTime - startTime;
      progBar.value = elapsed / totalDuration;
      if (elapsed < totalDuration) {
        progressAnimationFrame = requestAnimationFrame(updateProgress);
      }
    }

    // Play/Stop handlers.
    const startAudio = (e) => {
      e.preventDefault();
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      document.getElementById("piDisplay").textContent = "";
      scheduleEvents();
      updateProgress();
    };

    const stopAudio = () => {
      // To stop all scheduled sounds, we can close the AudioContext and create a new one.
      // (Alternatively, you could keep track of and stop individual oscillators.)
      audioCtx.close();
      if (progressAnimationFrame) cancelAnimationFrame(progressAnimationFrame);
    };

    // Add event listeners (supporting click, touchstart, and touchend).
    document.getElementById("play").addEventListener("click", startAudio);
    document.getElementById("play").addEventListener("touchend", startAudio);
    document.getElementById("play").addEventListener("touchstart", startAudio);

    document.getElementById("stop").addEventListener("click", stopAudio);
    document.getElementById("stop").addEventListener("touchend", stopAudio);
    document.getElementById("stop").addEventListener("touchstart", stopAudio);

  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nes.css/2.3.0/css/nes.min.css">
  <style>
    body {
      max-width: 80vw;
      margin: 1rem auto;
      font-family: monospace;
    }
    #piDisplay { font-size: 2.5vw; margin-top: 1em; }
  </style>
</head>

<body>
  <button class="nes-btn is-primary" id="play">Play Tones</button>
  <button class="nes-btn is-error" id="stop">Stop</button>
  <br><br>
  <progress class="nes-progress is-success" id="progress" value="0" max="1"></progress>
  <div id="piDisplay" class="nes-container is-rounded nes-text is-primary"></div>
  <div style="margin-top: 30vh" class="nes-container with-title is-centered">
    <p class="title">Credits</p>
    <p class="nes-text is-primary">Inspo: Tom</p>
    <p class="nes-text is-success">Theme: <a href="https://nostalgic-css.github.io/NES.css/" target="_blank">NES.css</a></p>
    <p class="nes-text">Calculate π to >16 digits: <a href="https://mathjs.org/" target="_blank">Math.js</a></p>
    <p class="nes-text is-error">Digital instruments: <a href="https://tonejs.github.io/" target="_blank">Tone.js</a></p>
  </div>
</body>
</html>
